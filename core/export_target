#!/bin/bash
# Copyright (c) 2012 - OpenSLX GmbH
#
# This program is free software distributed under the GPL version 2.
# See http://openslx.org/COPYING
#
# If you have any feedback please consult http://openslx.org/feedback and
# send your feedback to feedback@openslx.org
#
# General information about OpenSLX can be found at http://openslx.org
#
# Server side script to generate stage3.1,2 initial ramfses for OpenSLX Linux
# stateless clients
#############################################################################

# where we are
MODE_DIR="${ROOT_DIR}/core"

# files generated by this script land in boot
SERVER_BOOT_DIR="${ROOT_DIR}/var/boot/${REMOTE_IP}"

# builds from remote server
SERVER_BUILD_DIR="${ROOT_DIR}/var/build/${REMOTE_IP}"

# target directory
SERVER_CONFIGS_DIR="${ROOT_DIR}/configs"
SERVER_OVERLAY_CONFIGS_DIR="${ROOT_DIR}/overlay/configs"

# allow to specify a different remote export dir via ENV
[ -z $REMOTE_EXPORT_DIR ] && REMOTE_EXPORT_DIR="/export/build"

# initial checks
initial_checks() {

	local TOOL_STR="$TOOL_STR initial_checks:"

	[ -d "${SERVER_BOOT_DIR}" ] || mkdir -p "${SERVER_BOOT_DIR}"

}

copy_kernel() {
	#copy kernel to boot directory
	pinfo "Copying kernel from ${REMOTE_IP} to ${SERVER_BOOT_DIR}/kernel/"
	if [ -d ${SERVER_BUILD_DIR}/kernel ]; then
		cd ${SERVER_BUILD_DIR}
		tarcopy "kernel" "${SERVER_BOOT_DIR}"
		cd - &> /dev/null
	fi
}

sync_remote() {
	[[ "${#SERVER_BUILD_DIR}" -lt "10" ]] && perror "Safety check failed: SERVER_BUILD_DIR is less than 10 chars. ($SERVER_BUILD_DIR)"
	pinfo "Synching 'root@$REMOTE_IP:$REMOTE_EXPORT_DIR' to '$SERVER_BUILD_DIR'. This might take a while..."
	#TODO setup link to remote build directory, later this directory will be rsynced or exported to this server...
	
	mkdir -p "${SERVER_BUILD_DIR}" || perror "Could not create directory for local copy of remote system ($SERVER_BUILD_DIR)"
	rsync -a --numeric-ids --exclude '**/.mltk' --delete --delete-excluded -v -e "ssh -oStrictHostKeyChecking=no" "root@$REMOTE_IP:$REMOTE_EXPORT_DIR/*" "$SERVER_BUILD_DIR"
	local RET=$?
	if [ $RET -eq 0 ]; then
		pinfo "Syncing completed."
	else
		perror "Syncing of 'root@$REMOTE_IP:$REMOTE_EXPORT_DIR' to '$SERVER_BUILD_DIR' failed with error code: $RET. (Is '$REMOTE_EXPORT_DIR' available on target machine? If not run './mltk -n' on remote machine to export the build directory.)"
	fi
}

generate_config() {
	# generate config from the target directory
	local TOOL_STR="${TOOL_STR} generate_config:"
	pinfo "Generating config.tgz for '${SERVER_CONFIG_TYPE}'"

	# check if SERVER_EXPORT_TARGET is valid
	[ ! -z "${SERVER_CONFIG_TYPE}" ] || \
		perror "Server export config type not given! Valid types are: $(echo $(ls $SERVER_CONFIGS_DIR $SERVER_OVERLAY_CONFIGS_DIR))"
		
	[ -d "${SERVER_CONFIGS_DIR}/${SERVER_CONFIG_TYPE}" -o -d "${SERVER_OVERLAY_CONFIGS_DIR}/${SERVER_CONFIG_TYPE}" ] || \
		perror "Given export config not found: (${SERVER_CONFIGS_DIR}|${SERVER_OVERLAY_CONFIGS_DIR})/${SERVER_CONFIG_TYPE}"

	# directory where the activated modules are given
	# ex: server/configs/freiburg/
    [ -d "${SERVER_CONFIGS_DIR}/${SERVER_CONFIG_TYPE}" ] && \
	local TARGET_CONFIG_DIR="${SERVER_CONFIGS_DIR}/${SERVER_CONFIG_TYPE}"

    [ -d "${SERVER_OVERLAY_CONFIGS_DIR}/${SERVER_CONFIG_TYPE}" ] && \
	local TARGET_CONFIG_DIR="${SERVER_OVERLAY_CONFIGS_DIR}/${SERVER_CONFIG_TYPE}"

	# directory where the generated config.tgz will land
	local TARGET_CONFIG_FINAL_DIR="${SERVER_BOOT_DIR}/configs/${SERVER_CONFIG_TYPE}"
	[ ! -d "$TARGET_CONFIG_FINAL_DIR" ] && mkdir -p "$TARGET_CONFIG_FINAL_DIR"
	
	# directory where the sub-archives of modules will be built
	local TARGET_CONFIG_BUILD_DIR="${SERVER_BUILD_DIR}/configs/${SERVER_CONFIG_TYPE}"
	# always clean the build dir
	rm -rf "$TARGET_CONFIG_BUILD_DIR" && mkdir -p "$TARGET_CONFIG_BUILD_DIR"

	local TARGET_CONFIG_PATH="${TARGET_CONFIG_FINAL_DIR}/config.tar"
	local TARGET_CONFIG_FINAL_PATH="${TARGET_CONFIG_FINAL_DIR}/config.tgz"
	[ -e "$TARGET_CONFIG_PATH" ] && rm -f "$TARGET_CONFIG_PATH"
	[ -e "$TARGET_CONFIG_FINAL_PATH" ] && rm -f "$TARGET_CONFIG_FINAL_PATH"

	# now go over the activated modules and pack the contents into the tar archive
	for MODULE_CONFIG in $(ls "$TARGET_CONFIG_DIR"); do
		pinfo "\tGenerating sub-archive for '${MODULE_CONFIG}'"
		# add files in that directory to config.tgz
		cd "${TARGET_CONFIG_DIR}/${MODULE_CONFIG}" || perror "\tCould not cd to '${TARGET_CONFIG_DIR}/${MODULE_CONFIG}'"

		# check if files are already in another module config
		for FILE in $(find . -type f | cut -c 3-); do
			# check for all the archives we find in TARGET_CONFIG_BUILD_DIR
			for ARCHIV in $(ls "${TARGET_CONFIG_BUILD_DIR}/"*.tar 2>/dev/null); do
				if [ "x$(tar tvf "${ARCHIV}" | grep -E "${FILE}$")" != "x" ]; then
					# name of the module in conflict
					local CONFLICTING_MODULE="$(basename ${ARCHIV%.tar})"
					# file is present in archiv
					pwarning "\tFile '${FILE#.}' is already present in module config of '${CONFLICTING_MODULE}'."
					perror "\tResolve conflicts between '${CONFLICTING_MODULE}' and '${MODULE_CONFIG}', then try again."
				fi
			done

		done

		# no conflict, add file to archive
		tar --owner=root --group=root -c -f "${TARGET_CONFIG_BUILD_DIR}/${MODULE_CONFIG}.tar" $(ls)
		RET=$?
		[ "x$RET" != "x0" ] && perror "\tCould not create '${TARGET_CONFIG_BUILD_DIR}/${MODULE_CONFIG}.tar'"
	done

	# now we have packed all configs separately and can concatenate them all together.
	pinfo "Merging all sub-archive into one"
	for MODULE_CONFIG_ARCHIV in $(ls "${TARGET_CONFIG_BUILD_DIR}/"*.tar 2>/dev/null); do
		tar Af "${TARGET_CONFIG_PATH}" "${MODULE_CONFIG_ARCHIV}"
		RET=$?
		[ "x$RET" != "x0" ] && perror "Could not merge '${MODULE_CONFIG_ARCHIV}' into '${TARGET_CONFIG_PATH}.tar'"
	done

	# now gzip everything
	gzip "${TARGET_CONFIG_PATH}" || perror "Could not gzip '${TARGET_CONFIG_FINAL_PATH}'"
	mv "${TARGET_CONFIG_PATH}.gz" "${TARGET_CONFIG_FINAL_PATH}" \
		|| perror "Could not mv '${TARGET_CONFIG_PATH}.gz' to '${TARGET_CONFIG_FINAL_PATH}'"
	
	pinfo "Created config.tgz for '${SERVER_CONFIG_TYPE}' at '${TARGET_CONFIG_FINAL_PATH}'"
}

export_target() {

	initial_checks
	copy_kernel

	local TARGET="$1"
	[ -z "$TARGET" ] && perror "No target passed to export_target()"
	[ -d "${SERVER_BUILD_DIR}/${TARGET}" ] || perror "Given target directory does not exist: ${SERVER_BUILD_DIR}/${TARGET}"
	if [ -n "$3" ]; then
		local IGNORE="${SERVER_BUILD_DIR}/$3"
		[ -d "${IGNORE}" ] || perror "Given 'ignore target' does not exist: ${IGNORE}"
	fi

	case "$2" in
		cpio)
			local TOOL_STR="${TOOL_STR} generate_initramfs:"
			pinfo "Writing 'initramfs-${TARGET}' to '${SERVER_BOOT_DIR}/'"
			generate_initramfs "${SERVER_BUILD_DIR}/${TARGET}/" "." "${SERVER_BOOT_DIR}/initramfs-${TARGET}" "$IGNORE"
			;;
		sqfs)
			local TOOL_STR="${TOOL_STR} generate_squashfs:"
			pinfo "Creating '${TARGET}.sqfs' in '${SERVER_BOOT_DIR}/'"
			generate_squashfs "${SERVER_BUILD_DIR}/${TARGET}/" "${SERVER_BOOT_DIR}/${TARGET}.sqfs" "$IGNORE"
			;;
		*)
			perror "Invalid export format: $2"
			;;
	esac

}

clean_target() {
	TARGET=$1

	local TOOL_STR="$TOOL_STR clean_target"
	pinfo "Cleaning '${SERVER_BUILD_DIR}/${TARGET}'..."
	[ -d "${SERVER_BUILD_DIR}/${TARGET}" -a ! -h "${SERVER_BUILD_DIR}" ] && { rm -rf "${SERVER_BUILD_DIR}/${TARGET}" || perror "rm -rf failed."; }
	pinfo "Cleaning '${SERVER_BOOT_DIR}/kernel'..."
	[ -e "${SERVER_BOOT_DIR}/kernel" ] && { rm "${SERVER_BOOT_DIR}/kernel" || perror "rm failed."; }
	pinfo "Cleaning '${SERVER_BOOT_DIR}/initramfs-${TARGET}'..."
	[ -e "${SERVER_BOOT_DIR}/initramfs-${TARGET}" ] && { rm "${SERVER_BOOT_DIR}/initramfs-${TARGET}" || perror "rm failed."; }
	pinfo "Cleaning '${SERVER_BOOT_DIR}/${TARGET}.sqfs'..."
	[ -e "${SERVER_BOOT_DIR}/${TARGET}.sqfs" ] && { rm "${SERVER_BOOT_DIR}/${TARGET}.sqfs" || perror "rm failed."; }
	pinfo "Cleaning '${SERVER_BOOT_DIR}/stage32_dqfs/mnt/${TARGET}.sqfs'..."
	[ -e "${SERVER_BOOT_DIR}/stage32_sqfs/mnt/${TARGET}.sqfs" ] && { rm "${SERVER_BOOT_DIR}/stage32_sqfs/mnt/${TARGET}.sqfs" || perror "rm failed."; }
}
